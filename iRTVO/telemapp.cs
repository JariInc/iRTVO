// iracing telemetry SDK C-sharp dll import layer
// derived from telemapp.h


/*
 * Copyright (c) 2008 iRacing.com Motorsport Simulations, LLC.  
 *
 * Date			Who		What
 * 04-oct-2005	RJC		Brought into the FIRST environment
 * 05-apr-2002	RJC 	Created
 *
 ***************************************************************************
 *	
 *	Terminology:
 *		"The App" - refers to the telemetry gathering application
 *		"The Sim" - refers to the iRacing racing simulator
 *		"Telemetry" - refers to any data sent to the app by the sim
 *		"State data" - refers to a specific type of telemetry that
 *			identifies changes in the sim's state (like the sim
 *			has paused or unpaused, or a track has been loaded or
 *			unloaded).
 *		"Sample data" - refers to telemetry data that is generated
 *			each evenly-spaced time period (like the car's orientation
 *			and velocity, or the player's control inputs)
 *		"A sample" - refers to a set of sample data that was all
 *			generated by the sim at the same point in time in the
 *			simulated world.
 *	
 *	Overview:
 *	---------
 *	
 *	An app can tie into the iRacing simulator and gather telemetry
 *	from the sim as the sim is running.
 *	
 *	While the sim is running, it periodically checks to see whether
 *	an external telemetry application is running.  If ir finds one,
 *	the sim will establish communications with the app, and write
 *	telemetry (sample and state data) to the app as needed.
 *	
 *	The sim can only send telemetry to one external application at
 *	any given time.  If a second app tries to register itself as a
 *	gatherer, the attempt to register will fail.
 *	
 *	Once the app has begun, it can make certain requests to the sim
 *	(such as  indicating the types of telemetry in which it is interested).
 *	
 *	Once the sim has begun, it will process any such requests from
 *	the app.  The sim will also write both state data and sample data
 *	to the app as the data becomes available.  Examples of state
 *	data would be notifications whenever a track is loaded or
 *	unloaded, or whenever the player pauses or unpauses the sim.
 *	Examples of sample data would be the chassis velocity and
 *	orientation, and the player input (throttle, brake, etc.).
 *	
 *	The app must be capable of reading the telemetry from the sim
 *	at least as quickly as the sim generates it.  As of this writing,
 *	if all telemetry is turned on the sim will be spitting data
 *	at the app at close to 360Hz, and will generate on the order of
 *	100Kbytes per second of data.  Typically, though, it will only
 *	spit data at 60Hz, generating on the order of a few Kbytes per
 *	second.
 *	
 *	The buffer into which the telemetry is written is of a limited
 *	size, so the app will need to quickly process the data to keep
 *	the buffer from overflowing. If the buffer does overflow,
 *	nothing catastrophic will happen.  The sim will continue to run,
 *	but it will stop writing data until space becomes available in
 *	the buffer, and so some telemetry will be lost.  The app will
 *	be able to query whether the buffer has overflowed.
 *	
 *	
 *	More detail:
 *	------------
 *	
 *	All of the data types, functions, etc. in the iRacing telemetry
 *	API are in the namespace iRacingTelem.  As such, you'll need to
 *	either qualify your use of the API components, or issue a
 *		using namespace iRacingTelem;
 *	directive.
 *	
 *	The app indicates its desire to be a telemetry gatherer by
 *	calling the AppBegin() function, specifying the name of the
 *	simulator to which it wants to attach ("iRacing.com Simulator").
 *	If this function succeeds, it will return true, and the app
 *	is then obliged to call AppEnd() before exiting.  The app
 *	should not call AppEnd() if it did not successfully call
 *	AppBegin().
 *	
 *	The system works by using a shared memory area to which
 *	both the app and the sim have access.  AppBegin() is the
 *	routine that creates this shared memory area.  While the
 *	sim is running, it periodically tries to execute its corresponding
 *	SimBegin() routine, which looks to see if this shared memory
 *	area exists.  Requests made by the app are written into a
 *	queue in one part of this shared memory, and telemetry
 *	generated by the sim is written into a queue in another
 *	part of this memory.
 *	
 *	Once begun, the app can use the AppRequestDataItems() function
 *	to indicate to the sim what sample and/or state data it is
 *	interested in receiving.  It does not have to wait for the
 *	sim to start up before issuing this request.
 *	
 *	The simulator program updates its world at 60Hz.  This rate
 *	is fine for most things, but it isn't nearly sufficient for
 *	running the physics simulation.  To achieve the desired
 *	fidelity in the physics simulation, the simulator runs the
 *	physics a number of times each 60th of a second.  As of this
 *	writing, it runs the physics 6 times each 60th of a second,
 *	resulting in an underlying physics rate of 360Hz.  By default,
 *	the telemetry system will sample the physics at the 60Hz world
 *	update rate.  The app can use the AppRequestDataAtPhysicsRate()
 *	function to request data at the full 360Hz rate.  This will,
 *	obviously, generate 6 times the amount of data.
 *	
 *	By using AppRequestDataItems(), the app can ask for any of the
 *	data types listed in the eSimDataType enum, except those
 *	specifically noted.  The item types listed before
 *	kNoStateInfo are considered "sample" items.  Those that
 *	have been requested are generated as a group each 60th
 *	(or 360th) of a second.  While the system does not force
 *	you to do so, you should always request kSampleHeader if
 *	you also request any other sample item.  Items below
 *	kNoStateInfo are considered "state" items.  Those that have
 *	been requested are generated by the sim as needed.
 *
 *	Player car gauge data is sampled at 60Hz, even when 360Hz
 *	is the selected sample rate.  
 *	
 *	The heart of the system is the AppWaitForNewSample()
 *	function.  Calling AppWaitForNewSample() will
 *	read telemetry items from the sim until either a complete
 *	sample has been read, or a state item has been read, or
 *	the specified timeout has expired (approximate - do NOT
 *	use the timeout facility of this function to try to get
 *	your app to do something on an even time schedule).
 *	Specifying a zero timeout will cause AppWaitForNewSample
 *	to return immediately if neither a sample nor a bit of
 *	state telemetry is available.  If a complete sample has
 *	been read, AppWaitForNewSample will return true.
 *
 *	The telemetry system has buffers that will hold one of
 *	each type of telemetry item.  When AppWaitForNewSample
 *	reads a telemetry item from the sim, it stores it in the
 *	buffer for that item type, and sets an internal flag
 *	indicating that the app can query that item.  The app
 *	can call AppGetSimData, specifying the item type,
 *	to get at the data.  It will return a pointer to the data
 *	item if it is available, or NULL otherwise.
 *	
 *	Any of these item buffers could be overwritten the
 *	next time the app calls AppWaitForNewSample, so the app
 *	should NOT maintain pointers obtained from AppGetSimData
 *	across calls to AppWaitForNewSample.  The app may
 *	explicitly clear a particular item type by calling
 *	AppClearSimData for that type, or it can clear all sample
 *	items by calling AppClearSample
 *
 *	When AppWaitForNewSample returns true, the app can then call
 *	AppGetSimData() repeatedly, specifying the eSimDataType items
 *	it has requested, to access the sample data.  Once the app
 *	is done with this sample, it should call AppClearSample()
 *	to ensure that it can not inadvertently re-read part of this
 *	sample again.
 *	
 *	Note that since calling AppRequestDataItems() is asynchronous
 *	to the sim's telemetry generation, the app cannot assume
 *	that the next sample it reads after having called this
 *	function will reflect this request.  Thus, the app should
 *	ALWAYS test that AppGetSimData() has returned a non-NULL
 *	pointer.
 *	
 *	When AppWaitForNewSample() returns false, it will either be
 *	because the timeout expired, or a piece of state data was
 *	read, in which case its newStateData output parameter will
 *	be set to the eSimDataType enum identifying the piece of
 *	state data that was read from the sim.  The app can then
 *	call AppGetSimData() with this type to see the new state data.
 *	Note that calling AppClearSample() clears only sample data,
 *	not state data.
 *	
 *	
 *	Important notes:
 *	----------------
 *	
 *	The sim can generate telemetry at a high rate.  The buffer
 *	into which the telemetry is written is not particularly
 *	large, so the app must be prepared to read the telemetry
 *	quickly.  If the app falls behind and the buffer overflows,
 *	the sim will have to discard some telemetry.  When this
 *	happens, it's possible that only part of a sample will be
 *	written (though the sim will never write only part of a
 *	specific data item).  The app must be prepared to deal
 *	with partial samples.
 *	
 *	By default, the sim runs as a HIGH_PRIORITY_CLASS process.
 *	The sim is multi-threaded, and it runs all of its real-time
 *	threads at at least THREAD_PRIORITY_ABOVE_NORMAL.  All of
 *	these real-time threads run on a time schedule and will
 *	cooperatively put themselves to sleep when their processing
 *	of the current sim loop is complete.  The sim also has a
 *	non-real-time thread that it runs at THREAD_PRIORITY_BELOW_NORMAL.
 *	This thread never sleeps for more than a brief period, and will
 *	happily eat up almost all available CPU time.
 *	
 *	For your app to run effectively, you will need to
 *	also run it as a HIGH_PRIORITY_CLASS process by calling
 *	SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);
 *
 ***************************************************************************
 */

// It is the intent that this file be distributed with the sim
// for public use, so do NOT include any iRacing specific header
// files here!

using System;
//using System.Text;
//using System.Threading;
using System.Runtime.InteropServices;

public class iRacingTelem
{
	public const int	MAX_CARS = 64;
	public const int	MAX_SESSIONS = 9;
	public const int	STARTING_GRID = 8;

	public const int	LAPS_UNLIMITED = 32767;
	public const float	TIME_UNLIMITED = 604800.0f;	// One week

	public const float	TIME_INVALID = -1.0f;
	public const int	LAP_INVALID = -1;

	public const float	TM_LTR_FUEL_PER_KG = 1.3333333f; // liter per k-grams (fuel) (1.0/0.75)


	// The types of telemetry that the app can ask the sim to generate.
	// The first group are sample items, and will be generated as a
	// group each sampling period (60 or 360Hz).
	//
	// The second group are sample items, but will only be generated
	// at a 60Hz period.
	//
	// The third group are state items, and will be generated as the
	// need arises.
	//
	// You should never request either kNoStateInfo, or kSampleFooter,
	// as they are used internally by the telemetry system.
	public enum eSimDataType {
		// these samples are available at either 60Hz or 360Hz as selected
		kSampleHeader,
		kChassisData,
		kDrivelineData,
		kDriverInput,

		// these samples are available at only 60Hz, even when 360Hz is selected
		kSimRateData = 64,
		kGaugeData,
		kTireData,

		// Add any new per-sample items above here.
		// The app must NOT use this data type
		kNoStateInfo = 127,

		// Add any "state" data below here.
		kCurrentWeekend,	//deprecated
		kDriverInCar,
		kSimIsPaused,
		kSessionInfo,
		kCarInfo,
		kCameraInfo,
		kDriverInfo,
		kLapInfo,
		kCarInPitStall,
		kCurrentWeekendEx,	//replaces broken kCurrentWeekend

		// DO NOT ADD ANY ITEMS BELOW HERE
		// The app must NOT use this data type.
		kSampleFooter	= 255
	};


	////////////////////////////////////////////////////////////////////////////
	// The following data are sample items.
	////////////////////////////////////////////////////////////////////////////

	//------------------------------------------------------------------------
	// Each time the driver gets into the car (including whenever they hit
	// shift-R to reset the car), the sequence number will change.
	// Each 60th of a second when the player physics is run, tick will
	// increment by one.
	// If you're requesting data at the physics rate, you'll get 6 samples
	// each 60th of a second with the same tick value, but the step value
	// will count from [0..5].  If you're sampling at 60Hz, step will always
	// be 5.
	// time counts the number of simulation seconds since sequence was
	// incremented.  It does not increase while the sim is paused.
	[StructLayout(LayoutKind.Sequential, Pack=1)]
	public struct SampleHeader {
		public uint	sequence;		// Increments each time physics is reset
		public uint	tick;			// Increments each 1/60th of a second
		public int step;			// From 0..N if AtPhysicsRate()
		public double time;			// Elapsed sim-world seconds since reset
	};


	//------------------------------------------------------------------------
	// World coordinates:
	//		- right handed, with +z = up
	// From the driver's point of view sitting at the center of gravity of the car,..
	// Car coordinates:
	//		- right handed, with +z = up, +x = towards nose, +y towards left side
	//		- +yaw rotates the +x axis into the +y axis
	//		- +pitch rotates the +z axis into the +x axis
	//		- +roll rotates the +y axis into the +z axis
	[StructLayout(LayoutKind.Sequential, Pack=1)]
	public struct ChassisData {
		public float trkPct;		// Percentage of way around the track

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.R4)]
		public float[] v;			// velocity [x,y,z] (meters/sec)

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.R4)]
		public float[] q;			// orientation [yaw,pitch,roll] (radians)

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.R4)]
		public float[] w;			// angular velocity [carx,cary,carz] (radians/sec)

		public float steerT;		// torque on steering shaft (N*m, + => clockwise torque)
	};

	// NOTE:
	// For the chassis orientation, yaw is applied first, then pitch, then roll.
	// You can generate a 3x3 rotation matrix from car coordinates to world
	// coordinates from ChassisData.q as follows...
	//		- Let the prefix 'c' mean cos(x), and the prefix 's' mean sin(x)
	//		- Let the suffix 'y' mean yaw, 'p' mean pitch, and 'r' mean roll
	// so that, for example, 'cp' means cos(pitch), or cos(ChassisData.q[1]).
	// Then...
	//		m[0][0] = cp*cy;
	//		m[0][1] = cy*sp*sr - cr*sy;
	//		m[0][2] = cr*cy*sp + sr*sy;
	//		m[1][0] = cp*sy;
	//		m[1][1] = cr*cy + sp*sr*sy;
	//		m[1][2] = cr*sp*sy - cy*sr;
	//		m[2][0] = -sp;
	//		m[2][1] = cp*sr;
	//		m[2][2] = cp*cr;
	// Multiplying a vector by this matrix will rotate it from the car's
	// coordinate system into the world coordinate system.  Multiplying
	// a vector by the transpose of this matrix goes the other way.
	//
	// See the sample program for an example.  It computes lateral,
	// longitudinal, and normal G loads from (sequences of) this data.


	//------------------------------------------------------------------------
	[StructLayout(LayoutKind.Sequential, Pack=1)]
	public struct DrivelineData {
		public float engRPM;	// engine RPM
	};

	//------------------------------------------------------------------------
	[StructLayout(LayoutKind.Sequential, Pack=1)]
	public struct DriverInput {
		public float throttle;	// Percent applied
		public float brake;		// Percent applied
		public float clutch;	// Percent released (1 => foot off clutch)
		public float steer;		// Steering wheel angle in radians (+ clockwise)
		public int gear;		// reverse = <0, neutral = 0, fwd gear = >0
	};

	//------------------------------------------------------------------------
	[StructLayout(LayoutKind.Sequential, Pack=1)]
	public struct SimRateData {
		public int dummy;		// this is just a placeholder struct for now
	};

	//------------------------------------------------------------------------
	[StructLayout(LayoutKind.Sequential, Pack=1)]
	public struct GaugeData {
		public float rpm;				// current engine RPM
		public float maxSafeRpm;		// maximum rpm before engine is dammaged (redline), usualy 500 rpm above rev limiter
		public float maxRpm;			// max engine RPM recorded this session (telltale)
		public float waterTemp;			// in degrees Celcius
		public float fuelPress;			// in bar (1 bar ~= 14.7 psi)
		public float oilTemp;			// in degrees Celcius
		public float oilPress;			// in bar
		public float oilLevel;			// percent
		public float voltage;			// electrical system voltage
		public float speed;				// speedometer reading in KPH
		public float fuelKgMax;			// total Kg of fuel tank could hold
		public float fuelKgRemaining;	// Kg of fuel in tank

		[MarshalAs(UnmanagedType.I1)]
		public bool rpmWarning;			// RPM warning light
		[MarshalAs(UnmanagedType.I1)]
		public bool revLimiterEngaged;	// rev limeter warning light
		[MarshalAs(UnmanagedType.I1)]
		public bool waterTempWarning;	// water temp warning light
		[MarshalAs(UnmanagedType.I1)]
		public bool fuelPressureWarning;// fuel pressure warning light
		[MarshalAs(UnmanagedType.I1)]
		public bool oilPressureWarning;	// oil pressure warning light
		[MarshalAs(UnmanagedType.I1)]
		public bool brakeLight;			// brake lights on
		[MarshalAs(UnmanagedType.I1)]
		public bool abs;				// anti lock brakes activated
		[MarshalAs(UnmanagedType.I1)]
		public bool enginStalled;		// is engine runing
		[MarshalAs(UnmanagedType.I1)]
		public bool pitSpeedLimiter;	// pit speed limiter is engaged
	};

	//------------------------------------------------------------------------
	// Some of the items below have arrays of information per wheel.
	// These arrays are indexed in this order.
	public enum wheelIndex {
		kWheelLeftFront = 0,
		kWheelRightFront,
		kWheelLeftRear,
		kWheelRightRear
	};

	// Conversion factor: kiloPascal to pounds per square inch
	const float kPa_to_PSI = 0.1450377f;

	[StructLayout(LayoutKind.Sequential, Pack=1)]
	public struct TireD {
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.R4)]
		public float[] temp;		// Inner, Middle, Outer, (degrees C)

		public float pressure;		// Hot pressure (gauge) (kPa (kiloPascal))
		public float pctTreadwear;	// Percent tire is worn, 1.0 is a blown tire.
	}

	[StructLayout(LayoutKind.Sequential, Pack=1)]
	public struct TireData {
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4, ArraySubType = UnmanagedType.Struct)]
		public TireD[] w;			// LF, RF, LR, RR
	};

	////////////////////////////////////////////////////////////////////////////
	// The following data are state items.
	// They are generated at the first opportunity after
	// the event occurs.  This will generally be immediate unless
	// there is a data overrun in the sim telemetry buffer.
	////////////////////////////////////////////////////////////////////////////

	//------------------------------------------------------------------------
	// You get one of these whenever a new set of race weekend parameters
	// is proposed, or when the weekend becomes active or inactive.
	// See the sim's readme.txt for a description of the .sessions
	// and .options strings.  They're described in the off-line league
	// section.
	// this is deprecated in favor of the extended version CurrentWeekendEx
	[StructLayout(LayoutKind.Sequential, Pack = 1, CharSet = CharSet.Ansi)]
	public struct CurrentWeekend {
		[MarshalAs(UnmanagedType.I1)]
		public bool atTrack;		// Does the sim have a track loaded?
		 
		[MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)]
		public String track;		// track directory

		public float trackLength;	// meters

		[MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)]
		public String sessions;		// See off-line league section of

		[MarshalAs(UnmanagedType.ByValTStr, SizeConst=32)]
		public String options;		// readme.txt for descriptions.
	};

	//------------------------------------------------------------------------
	// You will get one of these whenever the player gets into, or out of
	// the car.  You might, or might not, get these messages when the
	// player hits shift-R to reset the car (you get them in single player,
	// you don't if the player is connected to a remote server in a
	// multiplayer race).
	[StructLayout(LayoutKind.Sequential, Pack=1)]
	public struct DriverInCar {
		[MarshalAs(UnmanagedType.I1)]
		public bool inCar;			// Is player in-car?

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.R4)]
		public float[] headPos;		// DEPRECATED - use CarInfo.headPos
	};

	// You will get one of these whenever the type of car that the
	// driver is using changes.
	[StructLayout(LayoutKind.Sequential, Pack = 1, CharSet = CharSet.Ansi)]
	public struct CarInfo {
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.R4)]
		public float[] headPos;		// driver's head position vector in chassis frame

		[MarshalAs(UnmanagedType.ByValTStr, SizeConst=128)]
		public String carPath;		// Directory of this car.
	};


	//------------------------------------------------------------------------
	// You get one of these whenever the sim is paused or unpaused,
	// even if the player is not currently driving.
	[StructLayout(LayoutKind.Sequential, Pack=1)]
	public struct SimIsPaused {
		[MarshalAs(UnmanagedType.I1)]
		public bool paused;		// Is the sim paused?
	};

	//------------------------------------------------------------------------
	// You will get one of these whenever one of the drivers in the race joins/quits
	[StructLayout(LayoutKind.Sequential, Pack = 1, CharSet = CharSet.Ansi)]
	public struct DriverInfoRow {
		public int carIdx;
		[MarshalAs(UnmanagedType.I1)]
		public bool valid;
		[MarshalAs(UnmanagedType.I1)]
		public bool onTrack;

		[MarshalAs(UnmanagedType.ByValTStr, SizeConst=8)]
		public String carNum;

		public int userID;

		[MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)]
		public String userName;

		[MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)]
		public String abbrevName;

		[MarshalAs(UnmanagedType.ByValTStr, SizeConst=8)]
		public String initials;

		public int carClassID;
		public int carID;

		[MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)]
		public String carPath;

		[MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)]
		public String carClassShortName;

		public int carClassRelSpeed;

		public int iRating;
		public int licLevel;
		public int licSubLevel;

		[MarshalAs(UnmanagedType.ByValTStr, SizeConst=16)]
		public String licColor;

		[MarshalAs(UnmanagedType.ByValTStr, SizeConst=32)]
		public String clubName;

		[MarshalAs(UnmanagedType.ByValTStr, SizeConst=32)]
		public String divisionName;
	};

	[StructLayout(LayoutKind.Sequential, Pack=1)]
	public struct DriverInfo {
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_CARS, ArraySubType = UnmanagedType.Struct)] 
		public DriverInfoRow[] row;

		public int playerCarIdx; // your car index
	};

	//------------------------------------------------------------------------
	// You will get one of these whenever a car crosses the start/finish line

	public enum ReasonOutType
	{
		REASON_OUT_NOT_OUT = 0,			// (default) not out of race
		REASON_OUT_DID_NOT_START,
		REASON_OUT_BRAKE_FAILURE,
		REASON_OUT_COOLANT_LEAK,
		REASON_OUT_RADIATOR_PROBLEM,
		REASON_OUT_ENGINE_FAILURE,
		REASON_OUT_ENGINE_HEADER,
		REASON_OUT_ENGINE_VALVE,
		REASON_OUT_ENGINE_PISTON,
		REASON_OUT_ENGINE_GEARBOX,
		REASON_OUT_ENGINE_CLUTCH,
		REASON_OUT_ENGINE_CAMSHAFT,
		REASON_OUT_ENGINE_IGNITION,
		REASON_OUT_ENGINE_FIRE,
		REASON_OUT_ENGINE_ELECTRICAL,
		REASON_OUT_FUEL_LEAK,
		REASON_OUT_FUEL_INJECTOR,
		REASON_OUT_FUEL_PUMP,
		REASON_OUT_FUEL_LINE,
		REASON_OUT_OIL_LEAK,
		REASON_OUT_OIL_LINE,
		REASON_OUT_OIL_PUMP,
		REASON_OUT_OIL_PRESSURE,
		REASON_OUT_SUSPENSION_FAILURE,
		REASON_OUT_TIRE_PUNCTURE,
		REASON_OUT_TIRE_PROBLEM,
		REASON_OUT_WHEEL_PROBLEM,
		REASON_OUT_ACCIDENT,
		REASON_OUT_RETIRED,
		REASON_OUT_DISQUALIFIED,
		REASON_OUT_NO_FUEL,
		REASON_OUT_BRAKE_LINE,
		REASON_OUT_LOST_CONNECTION,
		REASON_OUT_EJECTED,

		// Add New Reasons HERE!
		NUMBER_OF_REASONS_OUT,
		REASON_OUT_INVALID,
	};

	[StructLayout(LayoutKind.Sequential, Pack=1)]
	public struct LapInfoEntry {
		public float resTime;		// official results, varies with event type
									// can represent fastest lap, or average lap speed, etc.	
		public int resLap;			// (race=num,other=fastest)

		public float fastTime;		// fastest lap time/count
		public int fastLap;

		public float lastTime;		// last lap time

		public int lapsLed;
		public int lapsComplete;	//last lap count

		public ReasonOutType reasonOut;
		public int incidents;

		public int carIdx;
		public float lapsDriven;
	};

	[StructLayout(LayoutKind.Sequential, Pack=1)]
	public struct LapInfoSession {
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_CARS, ArraySubType = UnmanagedType.Struct)]
		public LapInfoEntry[] position;

		public LapInfoEntry	fastestLap;

		public int sessionNum;
		public int sessionCookie;		// changes if session restarted

		public int sessionType;			// eSessionType

		// The following info is only necessary for the race session
		public float averageLapTime;
		public int lapsComplete;
		public int numCautionFlags;
		public int numCautionLaps;
		public int numLeadChanges;

		[MarshalAs(UnmanagedType.I1)]
		public bool valid;
		[MarshalAs(UnmanagedType.I1)]
		public bool official;
		public int lapsTotal;
		public float timeTotal;
	};

	[StructLayout(LayoutKind.Sequential, Pack=1)]
	public struct LapInfo {
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_SESSIONS, ArraySubType = UnmanagedType.Struct)]
		public LapInfoSession[] sessions;

		public int curSession;
	};

	//------------------------------------------------------------------------
	// You will get one of these whenever the camera changes or focuses on another car
	// this does not reflect 'real time' but instead can be focusing on a moment in the past
	// if the replay is running.  So the driver selected may not match the current driver entry
	// table if they have exited the sim for some reason.

	[StructLayout(LayoutKind.Sequential, Pack = 1, CharSet = CharSet.Ansi)]
	public struct CameraInfo {
		public int carIdx;

		[MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)]
		public String cameraName;

		[MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)]
		public String groupName;
	};

	//------------------------------------------------------------------------
	// You will get one of these whenever a car enters/exits its pit stall
	// If you keep track of them you can monitor how many times a car pits
	// and how long the pit lasts
	[StructLayout(LayoutKind.Sequential, Pack=1)]
	public struct CarInPitStall {
		[MarshalAs(UnmanagedType.ByValArray, ArraySubType = UnmanagedType.I1, SizeConst = MAX_CARS)]
		public bool[] isInPitStall;		// Is the car in its pit stall?
	};

	//------------------------------------------------------------------------
	// These are the different session types.
	public enum eSessionType {
		kSessionTypeInvalid,
		kSessionTypeTesting,
		kSessionTypePracticeLone,
		kSessionTypePractice,
		kSessionTypeQualifyLone,
		kSessionTypeQualifyOpen,
		kSessionTypeRace,
		kSessionTypeGrid,		//not a session but the starting grid
	};

	// Any given session will proceed through one or more of these
	// session states.  Not all session types use all the states.
	// During ssGetInCar, the sim is waiting for drivers to get
	// into their cars before proceeding.
	// ssWarmup is during "Gentlemen, start your engines!"
	// ssParadeLaps is used during the pace lap at the start of the race.
	// ssRacing is used during the majority of most sessions.  It
	// includes caution periods during a race.
	// ssCheckered us used during the period of time from when
	// the checkered flag is shown to the race leader until the last
	// car running takes the checkered flag.
	// ssCoolDown covers the period of time after the session is
	// complete until the next session starts, or the weekend is
	// ended.
	public enum eSessionState {
		kSessionStateInvalid,
		kSessionStateGetInCar,
		kSessionStateWarmup,
		kSessionStateParadeLaps,
		kSessionStateRacing,
		kSessionStateCheckered,
		kSessionStateCoolDown
	};

	// The current track status - is the yellow flag out?
	public enum eSessionFlag {
		kFlagGreen,
		kFlagYellow,
		kFlagRed
	};

	// You will get a SessionInfo periodically whenever a race
	// weekend is active.
	// - sessionNum is the session index (the first sessionNum is 0).
	// - sessionCookie will change whenever a session is restarted.
	// It's pretty important that you pay attention to these two.
	// Whenever the sessionNum or sessionCookie changes, you'll want
	// to clear out any information you may have cached for this
	// and any later sessions (like lap crossings and standings -
	// see below).
	// - sessionType is one of the eSessionType values above.
	// - sessionState is one of the eSessionState values above.
	// - sessionFlag is one of the eSessionFlag values above.
	// - currentTime is the current session time - the number of
	// elapsed simulation seconds since the start of the session.
	// Simulation time does not advance while the sim is paused.
	// Simulation time (generally) advances more quickly than
	// real time when the sim is running in 'accelerated' time.
	// - timeRemaining reflects what is shown on the "time remaining"
	// field on the race weekend screen.  It is the number of seconds
	// remaining in the current state of the current session.  It is
	// possible that this value will be -1 immediately after a state
	// transition
	// - lapsRemaining will only be valid during sessions whose length
	// is limited to a particular number of laps (qualifying and race).

	[StructLayout(LayoutKind.Sequential, Pack=1)]
	public struct SessionInfo {
		public int sessionNum;
		public int sessionCookie;	// changes if session restarted
		public int sessionType;		// eSessionType
		public int sessionState;	// eSessionState
		public int sessionFlag;		// eSessionFlag
		public float currentTime;
		public float timeRemaining;
		public int lapsRemaining;
	};

	//------------------------------------------------------------------------
	// You will get one of these when the weekend starts
	// this replaces the CurrentWeekend structure with a more
	// complete implementation.

	[StructLayout(LayoutKind.Sequential, Pack=1)]
	public struct SessionParam {
		public int sessionType;		//eSessionType
		public int nLapsToAvg;
		public int laps;
		public float length;		// in seconds
	};

	public enum eEventType {
		kEventTypeInvalid,
		kEventTypeTesting,
		kEventTypePractice,
		kEventTypeQualify,
		kEventTypeTimeTrial,
		kEventTypeRace,
	};

	public enum eCategory {
		kCategoryInvalid = 0,
		kCategoryOval,
		kCategoryRoad,
	};

	// extended form of CurrentWeekend, breaks the strings out into usable parameters
	[StructLayout(LayoutKind.Sequential, Pack = 1, CharSet = CharSet.Ansi)]
	public struct CurrentWeekendEx {
		[MarshalAs(UnmanagedType.I1)]
		public bool atTrack;		// Does the sim have a track loaded?

		[MarshalAs(UnmanagedType.ByValTStr, SizeConst=64)]
		public String track;		// track directory

		public float trackLength;	// meters

		public int trackID;
		public int sessionID;
		public int subSessionID;
		public int seriesID;
		public int seasonID;
		[MarshalAs(UnmanagedType.I1)]
		public bool official;
		public int raceWeek;
		public int eventType;		//eEventType
		public int category;		//eCategory

		public int numSessions;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = MAX_SESSIONS, ArraySubType = UnmanagedType.Struct)]
		public SessionParam[] sessions;

		[MarshalAs(UnmanagedType.ByValTStr, SizeConst=512)]
		public String options;
	};


	////////////////////////////////////////////////////////////////////////////

	// Initialize the application end of the telemetry system.
	// - simName should be the name of the sim to which you want
	// to connect.  You can find this by right-clicking on
	// the simulator executable (iRacingSim.exe) and selecting
	// Properties.  On the General tab, find the Description: string.
	// Currently, this is "iRacing.com Simulator"
	// - Always leave the id parameter as it's default NULL value.
	// AppBegin will return true if it succeeds, or false otherwise.
	// The two most likely reasons that it will return false are:
	//	1: Another program is running that has called AppBegin
	//	2: The sim is running, it had already attached to a telemetry-
	//		gatherer, and that gatherer exited without calling AppEnd().
	[DllImport("iWrapClient.dll", CallingConvention = CallingConvention.StdCall)]
	[return: MarshalAs(UnmanagedType.I1)]
	public static extern bool AppBegin([InAttribute()] [MarshalAs(UnmanagedType.LPStr)] string simName, [InAttribute()] IntPtr id);

	// Will return true if AppBegin was called successfully,
	// and AppEnd has not yet been called.
	[DllImport("iWrapClient.dll", CallingConvention = CallingConvention.StdCall)]
	[return: MarshalAs(UnmanagedType.I1)]
	public static extern bool AppBegunQ();

	// Will return true once the simulator has started and
	// initialized its end of the telemetry system.  It will
	// continue to return true until the sim exits, or
	// AppEnd is called.
	[DllImport("iWrapClient.dll", CallingConvention = CallingConvention.StdCall)]
	[return: MarshalAs(UnmanagedType.I1)]
	public static extern bool AppCheckIfSimActiveQ();

	// If you've successfully called AppBegin, you should
	// call AppEnd to clean up the application end of the
	// telemetry system before your program terminates.
	// It is not necessary for you to wait until the sim
	// exits to use AppEnd.
	[DllImport("iWrapClient.dll", CallingConvention = CallingConvention.StdCall)]
	public static extern void AppEnd();


	// The following three functions will write your request
	// into a buffer that the sim will read and process at
	// its convenience.  If the request will not fit in the
	// available space in the buffer, it will return false.

	// Pass true to receive samples at 360Hz, false for 60Hz.
	// By default, samples are generated at 60Hz.
	[DllImport("iWrapClient.dll", CallingConvention = CallingConvention.StdCall)]
	[return: MarshalAs(UnmanagedType.I1)]
	public static extern bool AppRequestDataAtPhysicsRate([MarshalAs(UnmanagedType.I1)] bool yes);

	// The set you pass here replaces your prior request.
	// Note that you must also call AppEnableSampling() if any
	// of the data items that you've requested are sample items.
	// By default, no telemetry is generated.
	[DllImport("iWrapClient.dll", CallingConvention = CallingConvention.StdCall)]
	[return: MarshalAs(UnmanagedType.I1)]
	public static extern bool AppRequestDataItems(int nItems, [InAttribute()] eSimDataType[] itemTypes);

	// Pass true to enable sample generation, false to disable.
	// This only affects sample items.  Requested state items
	// will still be generated even if this is called with false.
	// By default, telemetry generation is disabled.
	[DllImport("iWrapClient.dll", CallingConvention = CallingConvention.StdCall)]
	[return: MarshalAs(UnmanagedType.I1)]
	public static extern bool AppEnableSampling([MarshalAs(UnmanagedType.I1)] bool yes);


	// This is the routine you call to read telemetry (both
	// sample data, and state date) from the sim.
	// Pass a negative timeout value to wait forever (not recommended)
	// Pass 0 to return immediately once a complete sample,
	// has been read, or a state item has been read, or the
	// telemetry buffer is empty.
	// There are three possibilities when this routine returns:
	//	+ it returns true
	//		- a new sample is available.  use appGetSimData() for
	//		  each type of sample data you've requested (being
	//		  careful to test for NULL).
	//		- newStateData will be set to kNoStateInfo,
	//	+ it returns false, and newStateData != kNoStateInfo
	//		- a new piece of state data is available.  call
	//		  appGetSimData(newStateData) to examine the state data.
	//	+ it returns false, and newStateData == kNoStateInfo
	//		- no new state info was read, and there is not yet a
	//		  new sample available.  It is possible that part of
	//		  a new sample may have been read.
	[DllImport("iWrapClient.dll", CallingConvention = CallingConvention.StdCall)]
	[return: MarshalAs(UnmanagedType.I1)]
	public static extern bool AppWaitForNewSample(ref eSimDataType newStateData, int timeoutMillisecs);

	// Clear the most recently generated sample.  It is not
	// necessary for you to call this, but you might use it to
	// prevent inadvertent reuse of a sample.
	[DllImport("iWrapClient.dll", CallingConvention = CallingConvention.StdCall)]
	public static extern void AppClearSample();

	// You can use this to clear a particular bit of telemetry.
	[DllImport("iWrapClient.dll", CallingConvention = CallingConvention.StdCall)]
	public static extern void AppClearSimData(eSimDataType dataType);

	// Access the most recently generated bit of telemetry
	// of the specified type.  See Overview discussion above
	// for importance of checking the return value for NULL.
	[DllImport("iWrapClient.dll", CallingConvention = CallingConvention.StdCall)]
	public static extern IntPtr AppGetSimData(eSimDataType dataType);

	// Determine the size of the most recently generated bit
	// of telemetry of this type.  For most items, this will
	// return either 0 if the item has been cleared, or the
	// sizeof() the item's struct.  If a particular item's
	// description indicates that the sim will generate multiple
	// copies of the item at once, then this will return
	// N * sizeof(the struct).  Currently (8-oct-2008) there
	// are no items for which multiple copies will be generated
	// at once.
	[DllImport("iWrapClient.dll", CallingConvention = CallingConvention.StdCall)]
	public static extern int AppGetSimDataSize(eSimDataType dataType);


	// See if the telemetry buffer has overrun.  Each time the
	// sim tries to write a bit of telemetry, and there is not
	// enough space in the buffer for it, it will set this flag.
	// Once set, this flag will remain true until you (the app)
	// clears it.
	[DllImport("iWrapClient.dll", CallingConvention = CallingConvention.StdCall)]
	[return: MarshalAs(UnmanagedType.I1)]
	public static extern bool AppCheckIfSimDataOverrunQ();

	// Clear the telemetry overrun flag.  
	[DllImport("iWrapClient.dll", CallingConvention = CallingConvention.StdCall)]
	public static extern void AppClearSimDataOverrun();


	// AppRequestDataAtPhysicsRate, AppRequestDataItems, and
	// AppEnableSampling write your requests into a small buffer
	// that the sim reads and processes at its leisure.  If you
	// call one of these functions, and it returns false, it will
	// be because this buffer is currently full.  You can call
	// this function to flag that this has happened.  The sim
	// will clear this flag whenever it reads a request from
	// the buffer.
	[DllImport("iWrapClient.dll", CallingConvention = CallingConvention.StdCall)]
	public static extern void AppSetAppDataOverrun();

	// Will return true if you have called AppSetAppDataOverrun,
	// and the sim has not yet cleared this flag.
	[DllImport("iWrapClient.dll", CallingConvention = CallingConvention.StdCall)]
	[return: MarshalAs(UnmanagedType.I1)]
	public static extern bool AppCheckIfAppDataOverrunQ();
}
